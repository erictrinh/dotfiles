[
  {
    "name": "application",
    "doc": "Manipulate running applications.",
    "items": [
      {
        "def": "application:visiblewindows() -> win[]",
        "doc": "Returns only the app's windows that are visible.",
        "name": "visiblewindows"
      },
      {
        "def": "application.launchorfocus(name)",
        "doc": "Launches the app with the given name, or activates it if it's already running.",
        "name": "launchorfocus"
      },
      {
        "def": "application:activate(allwindows = false) -> bool",
        "doc": "Tries to activate the app (make its key window focused) and returns whether it succeeded; if allwindows is true, all windows of the application are brought forward as well.",
        "name": "activate"
      },
      {
        "def": "application.runningapplications() -> app[]",
        "doc": "Returns all running apps.",
        "name": "runningapplications"
      },
      {
        "def": "application.applicationforpid(pid) -> app or nil",
        "doc": "Returns the running app for the given pid, if it exists.",
        "name": "applicationforpid"
      },
      {
        "def": "application.applicationsforbundleid(bundleid) -> app[]",
        "doc": "Returns any running apps that have the given bundleid.",
        "name": "applicationsforbundleid"
      },
      {
        "def": "application:allwindows() -> window[]",
        "doc": "Returns all open windows owned by the given app.",
        "name": "allwindows"
      },
      {
        "def": "application:mainwindow() -> window",
        "doc": "Returns the main window of the given app, or nil.",
        "name": "mainwindow"
      },
      {
        "def": "application:title() -> string",
        "doc": "Returns the localized name of the app (in UTF8).",
        "name": "title"
      },
      {
        "def": "application:bundleid() -> string",
        "doc": "Returns the bundle identifier of the app.",
        "name": "bundleid"
      },
      {
        "def": "application:unhide() -> success",
        "doc": "Unhides the app (and all its windows) if it's hidden.",
        "name": "unhide"
      },
      {
        "def": "application:hide() -> success",
        "doc": "Hides the app (and all its windows).",
        "name": "hide"
      },
      {
        "def": "application:kill()",
        "doc": "Tries to terminate the app.",
        "name": "kill"
      },
      {
        "def": "application:kill9()",
        "doc": "Assuredly terminates the app.",
        "name": "kill9"
      },
      {
        "def": "application:ishidden() -> bool",
        "doc": "Returns whether the app is currently hidden.",
        "name": "ishidden"
      },
      {
        "def": "application:pid() -> number",
        "doc": "Returns the app's process identifier.",
        "name": "pid"
      },
      {
        "def": "application:kind() -> number",
        "doc": "Returns 1 if the app is in the dock, 0 if not, and -1 if it can't even have GUI elements if it wanted to.",
        "name": "kind"
      }
    ]
  },
  {
    "name": "audiodevice",
    "doc": "Manipulate the system's audio devices.",
    "items": [
      {
        "def": "audiodevice.alloutputdevices() -> audio[]",
        "doc": "Returns a list of all connected output devices.",
        "name": "alloutputdevices"
      },
      {
        "def": "audiodevice.defaultoutputdevice() -> audio or nil",
        "doc": "Gets the system's default audio device, or nil, it it does not exist.",
        "name": "defaultoutputdevice"
      },
      {
        "def": "audiodevice:setdefaultoutputdevice() -> bool",
        "doc": "Sets the system's default audio device to this device. Returns true if the audio device was successfully set.",
        "name": "setdefaultoutputdevice"
      },
      {
        "def": "audiodevice:name() -> string or nil",
        "doc": "Returns the name of the audio device, or nil if it does not have a name.",
        "name": "name"
      },
      {
        "def": "audiodevice:muted() -> bool or nil",
        "doc": "Returns true/false if the audio device is muted, or nil if it does not support being muted.",
        "name": "muted"
      },
      {
        "def": "audiodevice:setmuted(bool) -> bool",
        "doc": "Returns true if the the device's muted status was set, or false if it does not support being muted.",
        "name": "setmuted"
      },
      {
        "def": "audiodevice:volume() -> number or bool",
        "doc": "Returns a number between 0 and 100 inclusive, representing the volume percentage. Or nil, if the audio device does not have a volume level.",
        "name": "volume"
      },
      {
        "def": "audiodevice:setvolume(level) -> bool",
        "doc": "Returns true if the volume was set, or false if the audio device does not support setting a volume level. Level is a percentage between 0 and 100.",
        "name": "setvolume"
      }
    ]
  },
  {
    "name": "battery",
    "doc": "Functions for getting battery info. All functions here may return nil, if the information requested is not available.",
    "items": [
      {
        "def": "battery.cycles() -> number",
        "doc": "Returns the number of cycles the connected battery has went through.",
        "name": "cycles"
      },
      {
        "def": "battery.name() -> number",
        "doc": "Returns the name of the battery.",
        "name": "name"
      },
      {
        "def": "battery.maxcapacity() -> number",
        "doc": "Returns the current maximum capacity of the battery in mAh.",
        "name": "maxcapacity"
      },
      {
        "def": "battery.capacity() -> number",
        "doc": "Returns the current capacity of the battery in mAh.",
        "name": "capacity"
      },
      {
        "def": "battery.designcapacity() -> number",
        "doc": "Returns the design capacity of the battery in mAh.",
        "name": "designcapacity"
      },
      {
        "def": "battery.voltage() -> number",
        "doc": "Returns the voltage flow of the battery in mV.",
        "name": "voltage"
      },
      {
        "def": "battery.amperage() -> number",
        "doc": "Returns the amperage of the battery in mA. (will be negative if battery is discharging)",
        "name": "amperage"
      },
      {
        "def": "battery.watts() -> number",
        "doc": "Returns the watts into or out of the battery in Watt (will be negative if battery is discharging)",
        "name": "watts"
      },
      {
        "def": "battery.health() -> string",
        "doc": "Returns the health status of the battery. One of {Good, Fair, Poor}",
        "name": "health"
      },
      {
        "def": "battery.healthcondition() -> string",
        "doc": "Returns the health condition status of the battery. One of {Check Battery, Permanent Battery Failure}. Nil if there is no health condition set.",
        "name": "healthcondition"
      },
      {
        "def": "battery.percentage() -> number",
        "doc": "Returns the current percentage of the battery between 0 and 100.",
        "name": "percentage"
      },
      {
        "def": "battery.timeremaining() -> number",
        "doc": "Returns the time remaining in minutes. Or a negative value: -1 = calculating time remaining, -2 = unlimited (i.e. you're charging, or apple has somehow discovered an infinite power source.)",
        "name": "timeremaining"
      },
      {
        "def": "battery.timetofullcharge() -> number",
        "doc": "Returns the time remaining to a full charge in minutes. Or a negative value, -1 = calculating time remaining.",
        "name": "timetofullcharge"
      },
      {
        "def": "battery.ischarging() -> boolean",
        "doc": "Returns true if the battery is charging.",
        "name": "ischarging"
      },
      {
        "def": "battery.ischarged() -> boolean",
        "doc": "Returns true if battery is charged.",
        "name": "ischarged"
      },
      {
        "def": "battery.isfinishingcharge() -> boolean",
        "doc": "Returns true if battery is finishing charge.",
        "name": "isfinishingcharge"
      }
    ]
  },
  {
    "name": "battery.watcher",
    "doc": "Functions for watching battery state changes.",
    "items": [
      {
        "def": "battery.watcher.new(fn) -> battery.watcher",
        "doc": "Creates a battery watcher that can be started. When started, fn will be called each time a battery attribute changes.",
        "name": "new"
      },
      {
        "def": "battery.watcher:start() -> self",
        "doc": "Starts the battery watcher, making it so fn is called each time a battery attribute changes.",
        "name": "start"
      },
      {
        "def": "battery.watcher:stop() -> self",
        "doc": "Stops the battery watcher's fn from getting called until started again.",
        "name": "stop"
      },
      {
        "def": "battery.watcher.stopall()",
        "doc": "Stops all running battery watchers; called automatically when user config reloads.",
        "name": "stopall"
      }
    ]
  },
  {
    "name": "brightness",
    "doc": "Functions for manipulating display brightness.",
    "items": [
      {
        "def": "brightness.set(number) -> boolean",
        "doc": "Sets the display brightness. Number should be between 0 and 100.",
        "name": "set"
      },
      {
        "def": "brightness.get() -> number",
        "doc": "Returns the current brightness of the display.",
        "name": "get"
      }
    ]
  },
  {
    "name": "ext",
    "doc": "Standard high-level namespace for third-party extensions.",
    "items": [

    ]
  },
  {
    "name": "fnutils",
    "doc": "Super-helpful functional programming utilities.",
    "items": [
      {
        "def": "fnutils.map(t, fn) -> t",
        "doc": "Returns a table of the results of fn(el) on every el in t.",
        "name": "map"
      },
      {
        "def": "fnutils.each(t, fn) -> t",
        "doc": "Runs fn(el) for every el in t.",
        "name": "each"
      },
      {
        "def": "fnutils.filter(t, fn) -> t",
        "doc": "Returns a table of the elements in t in which fn(el) is truthy.",
        "name": "filter"
      },
      {
        "def": "fnutils.copy(t) -> t2",
        "doc": "Returns a new copy of t using pairs(t).",
        "name": "copy"
      },
      {
        "def": "fnutils.contains(t, el) -> bool",
        "doc": "Returns whether the table contains the given element.",
        "name": "contains"
      },
      {
        "def": "fnutils.indexof(t, el) -> int or nil",
        "doc": "Returns the index of a given element in a table, or nil if not found.",
        "name": "indexof"
      },
      {
        "def": "fnutils.concat(t1, t2)",
        "doc": "Adds all elements of t2 to the end of t1.",
        "name": "concat"
      },
      {
        "def": "fnutils.mapcat(t, fn) -> t2",
        "doc": "Runs fn(el) for every el in t, and assuming the results are tables, combines them into a new table.",
        "name": "mapcat"
      },
      {
        "def": "fnutils.reduce(t, fn) -> t2",
        "doc": "Runs fn(el1, el2) for every el in t, then fn(result, el3), etc, until there's only one left.",
        "name": "reduce"
      },
      {
        "def": "fnutils.find(t, fn) -> el",
        "doc": "Returns the first element where fn(el) is truthy.",
        "name": "find"
      },
      {
        "def": "fnutils.sequence(...) -> fn",
        "doc": "Returns a list of the results of the passed functions.",
        "name": "sequence"
      },
      {
        "def": "fnutils.partial(fn, ...) -> fn'",
        "doc": "Returns fn partially applied to arg (...).",
        "name": "partial"
      }
    ]
  },
  {
    "name": "geometry",
    "doc": "Mathy stuff.",
    "items": [
      {
        "def": "geometry.rotateccw(point, aroundpoint, ntimes = 1) -> point",
        "doc": "Rotates a point around another point N times.",
        "name": "rotateccw"
      },
      {
        "def": "geometry.hypot(point) -> number",
        "doc": "Returns hypotenuse of a line defined from 0,0 to point.",
        "name": "hypot"
      },
      {
        "def": "geometry.rect(x, y, w, h) -> rect",
        "doc": "Convenience function for creating a rect-table.",
        "name": "rect"
      },
      {
        "def": "geometry.point(x, y) -> point",
        "doc": "Convenience function for creating a point-table.",
        "name": "point"
      },
      {
        "def": "geometry.size(w, h) -> size",
        "doc": "Convenience function for creating a size-table.",
        "name": "size"
      },
      {
        "def": "geometry.intersectionrect(rect1, rect2) -> rect3",
        "doc": "Returns the intersection of two rects as a new rect.",
        "name": "intersectionrect"
      },
      {
        "def": "geometry.rectmidpoint(rect) -> point",
        "doc": "Returns the midpoint of a rect.",
        "name": "rectmidpoint"
      }
    ]
  },
  {
    "name": "hotkey",
    "doc": "Create and manage global hotkeys.",
    "items": [
      {
        "def": "hotkey.bind(mods, key, pressedfn, releasedfn) -> hotkey",
        "doc": "Shortcut for: return hotkey.new(mods, key, pressedfn, releasedfn):enable()",
        "name": "bind"
      },
      {
        "def": "hotkey.inputsourcechanged()",
        "doc": "Called when your input source (i.e. qwerty, dvorak, colemac) changes.\nDefault implementation does nothing; you may override this to rebind your hotkeys or whatever.",
        "name": "inputsourcechanged"
      },
      {
        "def": "hotkey.keycodes",
        "doc": "A mapping from string representation of a key to its keycode, and vice versa; not generally useful yet.\nFor example: keycodes[1] == \"s\", and keycodes[\"s\"] == 1, and so on",
        "name": "keycodes"
      },
      {
        "def": "hotkey.new(mods, key, pressedfn, releasedfn = nil) -> hotkey",
        "doc": "Creates a new hotkey that can be enabled.\n\nThe `mods` parameter is case-insensitive and may contain any of the following strings: \"cmd\", \"ctrl\", \"alt\", or \"shift\".\n\nThe `key` parameter is case-insensitive and may be any single-character string; it may also be any of the following strings:\n\n    F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15,\n    F16, F17, F18, F19, F20, PAD, PAD*, PAD+, PAD/, PAD-, PAD=,\n    PAD0, PAD1, PAD2, PAD3, PAD4, PAD5, PAD6, PAD7, PAD8, PAD9,\n    PAD_CLEAR, PAD_ENTER, RETURN, TAB, SPACE, DELETE, ESCAPE, HELP,\n    HOME, PAGE_UP, FORWARD_DELETE, END, PAGE_DOWN, LEFT, RIGHT, DOWN, UP\n\nThe `pressedfn` parameter is the function that will be called when this hotkey is pressed.\n\nThe `releasedfn` parameter is the function that will be called when this hotkey is released; this field is optional (may be nil or omitted).",
        "name": "new"
      },
      {
        "def": "hotkey:enable() -> self",
        "doc": "Registers the hotkey's fn as the callback when the user presses key while holding mods.",
        "name": "enable"
      },
      {
        "def": "hotkey:disable() -> self",
        "doc": "Disables the given hotkey; does not remove it from hotkey.keys.",
        "name": "disable"
      },
      {
        "def": "hotkey.disableall()",
        "doc": "Disables all hotkeys; automatically called when user config reloads.",
        "name": "disableall"
      }
    ]
  },
  {
    "name": "hotkey.modal",
    "doc": "For conveniently binding modal hotkeys.\n\nThis would be a simple example usage:\n\n    k = hotkey.modal.new({\"cmd\", \"shift\"}, \"d\")\n\n    function k:entered() hydra.alert('Entered mode') end\n    function k:exited()  hydra.alert('Exited mode')  end\n\n    k:bind({}, 'escape', function() k:exit() end)\n    k:bind({}, 'J', function() hydra.alert(\"Pressed J\") end)",
    "items": [
      {
        "def": "hotkey.modal:entered()",
        "doc": "Optional callback for when a modal is entered; default implementation does nothing.",
        "name": "entered"
      },
      {
        "def": "hotkey.modal:exited()",
        "doc": "Optional callback for when a modal is exited; default implementation does nothing.",
        "name": "exited"
      },
      {
        "def": "hotkey.modal:bind(mods, key, pressedfn, releasedfn)",
        "doc": "Registers a new hotkey that will be bound when the modal is enabled.",
        "name": "bind"
      },
      {
        "def": "hotkey.modal:enter()",
        "doc": "Enables all hotkeys created via `modal:bind` and disables the modal itself.\nCalled automatically when the modal's hotkey is pressed.",
        "name": "enter"
      },
      {
        "def": "hotkey.modal:exit()",
        "doc": "Disables all hotkeys created via `modal:bind` and re-enables the modal itself.",
        "name": "exit"
      },
      {
        "def": "hotkey.modal.new(mods, key) -> modal",
        "doc": "Creates a new modal hotkey and enables it.\nWhen mods and key are pressed, all keys bound via `modal:bind` will be enabled.\nThey are disabled when the \"mode\" is exited via `modal:exit()`",
        "name": "new"
      }
    ]
  },
  {
    "name": "http",
    "doc": "For making HTTP/HTTPS requests",
    "items": [
      {
        "def": "http.send(url, method, timeout, headers, body, fn(code, header, data, err))",
        "doc": "Send an HTTP request using the given method, with the following parameters:\n  url must be a string\n  method must be a string (i.e. \"GET\")\n  timeout must be a number\n  headers must be a table; may be empty; any keys and values present must both be strings\n  body may be a string or nil\n  fn must be a valid function, and is called with the following parameters:\n    code is a number (is sometimes 0, I think?)\n    header is a table of string->string pairs\n    data is a string on success, nil on failure\n    err is a string on failure, nil on success",
        "name": "send"
      }
    ]
  },
  {
    "name": "hydra",
    "doc": "General stuff.",
    "items": [
      {
        "def": "hydra.docsfile() -> string",
        "doc": "Returns the path of a JSON file containing the docs, for you to generate pretty docs with. The top-level is a list of groups. Groups have keys: name (string), doc (string), items (list of items); Items have keys: name (string), def (string), doc (string).",
        "name": "docsfile"
      },
      {
        "def": "hydra.reload()",
        "doc": "Reloads your init-file. Makes sure to clear any state that makes sense to clear (hotkeys, pathwatchers, etc).",
        "name": "reload"
      },
      {
        "def": "hydra.errorhandler = function(err)",
        "doc": "Error handler for hydra.call; intended for you to set, not for third party libs",
        "name": "errorhandler"
      },
      {
        "def": "hydra.call(fn, ...) -> ...",
        "doc": "Just like pcall, except that failures are handled using hydra.errorhandler",
        "name": "call"
      },
      {
        "def": "hydra.exec(command) -> string",
        "doc": "Runs a shell function and returns stdout as a string (may include trailing newline).",
        "name": "exec"
      },
      {
        "def": "hydra.version -> string",
        "doc": "The current version of Hydra, as a human-readable string.",
        "name": "version"
      },
      {
        "def": "hydra.licenses -> string",
        "doc": "Returns a string containing the licenses of all the third party software Hydra uses (i.e. Lua)",
        "name": "licenses"
      },
      {
        "def": "hydra.showabout()",
        "doc": "Displays the standard OS X about panel; implicitly focuses Hydra.",
        "name": "showabout"
      },
      {
        "def": "hydra.focushydra()",
        "doc": "Makes Hydra the currently focused app; useful in combination with textgrids.",
        "name": "focushydra"
      },
      {
        "def": "hydra.alert(str, seconds = 2)",
        "doc": "Shows a message in large words briefly in the middle of the screen; does tostring() on its argument for convenience..",
        "name": "alert"
      },
      {
        "def": "hydra.fileexists(path) -> exists, isdir",
        "doc": "Checks if a file exists, and whether it's a directory.",
        "name": "fileexists"
      },
      {
        "def": "hydra.check_accessibility(shouldprompt) -> isenabled",
        "doc": "Returns whether accessibility is enabled. If passed `true`, prompts the user to enable it.",
        "name": "check_accessibility"
      },
      {
        "def": "hydra.setosxshadows(bool)",
        "doc": "Sets whether OSX apps have shadows.",
        "name": "setosxshadows"
      },
      {
        "def": "hydra.uuid() -> string",
        "doc": "Returns a UUID as a string",
        "name": "uuid"
      }
    ]
  },
  {
    "name": "hydra.autolaunch",
    "doc": "Functions for controlling whether Hydra launches at login.\n\nTo make sure Hydra launches at login, put this in your config:\n\n    hydra.autolaunch.set(true)",
    "items": [
      {
        "def": "hydra.autolaunch.get() -> bool",
        "doc": "Returns whether Hydra launches when you login.",
        "name": "get"
      },
      {
        "def": "hydra.autolaunch.set(bool)",
        "doc": "Sets whether Hydra launches when you login.",
        "name": "set"
      }
    ]
  },
  {
    "name": "hydra.dockicon",
    "doc": "Functions for controlling Hydra's own dock icon.",
    "items": [
      {
        "def": "hydra.dockicon.visible() -> bool",
        "doc": "Returns whether Hydra has a Dock icon, and thus can be switched to via Cmd-Tab.",
        "name": "visible"
      },
      {
        "def": "hydra.dockicon.show()",
        "doc": "Shows Hydra's dock icon; Hydra can then be switched to via Cmd-Tab.",
        "name": "show"
      },
      {
        "def": "hydra.dockicon.hide()",
        "doc": "Hides Hydra's dock icon; Hydra will no longer show up when you Cmd-Tab.",
        "name": "hide"
      },
      {
        "def": "hydra.dockicon.bounce(indefinitely = false)",
        "doc": "Bounces Hydra's dock icon; if indefinitely is true, won't stop until you click the dock icon.",
        "name": "bounce"
      },
      {
        "def": "hydra.dockicon.setbadge(str)",
        "doc": "Set's Hydra's dock icon's badge to the given string; pass an empty string to clear it.",
        "name": "setbadge"
      }
    ]
  },
  {
    "name": "hydra.ipc",
    "doc": "Interface with Hydra from the command line.",
    "items": [
      {
        "def": "hydra.ipc.handler(str) -> value",
        "doc": "The default handler for IPC, called by hydra-cli. Default implementation evals the string and returns the result.\nYou may override this function if for some reason you want to implement special evaluation rules for executing remote commands.\nThe return value of this function is always turned into a string via tostring() and returned to hydra-cli.\nIf an error occurs, the error message is returned instead.",
        "name": "handler"
      }
    ]
  },
  {
    "name": "hydra.menu",
    "doc": "Control Hydra's menu-bar icon.\n\nHere's a simple example:\n\n    hydra.menu.show(function()\n      return {\n        {title = 'About Hydra', fn = hydra.showabout},\n        {title = '-'},\n        {title = 'Quit', fn = os.exit},\n      }\n    end)",
    "items": [
      {
        "def": "hydra.menu.show(fn() -> itemstable)",
        "doc": "Shows Hyra's menubar icon. The function should return a table of tables with keys: title, fn, checked (optional), disabled (optional)",
        "name": "show"
      },
      {
        "def": "hydra.menu.hide()",
        "doc": "Hides Hydra's menubar icon.",
        "name": "hide"
      }
    ]
  },
  {
    "name": "hydra.packages",
    "doc": "Package management for third party Hydra libraries.\n\nPut `hydra.packages.setup()` at the top of your initfile; it does nothing if it's already been setup.\n\nSee `hydra.packages.list` and `hydra.packages.install` to get started.",
    "items": [
      {
        "def": "hydra.packages.cachedirectory -> string",
        "doc": "Absolute path of packages cache, unquoted; defaults to ~/.hydra-ext",
        "name": "cachedirectory"
      },
      {
        "def": "hydra.packages.setup()",
        "doc": "Clones https://github.com/sdegutis/hydra-ext into hydra.packages.cachedirectory if it's not already there.",
        "name": "setup"
      },
      {
        "def": "hydra.packages.list()",
        "doc": "Lists available and installed packages.",
        "name": "list"
      },
      {
        "def": "hydra.packages.list(name[, version])",
        "doc": "Shows information about a given package.",
        "name": "list"
      },
      {
        "def": "hydra.packages.listinstalled()",
        "doc": "Lists only installed packages.",
        "name": "listinstalled"
      },
      {
        "def": "hydra.packages.install(name[, version])",
        "doc": "Installs the given package.\nIf version is omitted, defaults to the latest version.\nChanges take effect immediately, so that you may use `require \"packagename\"` without restarting Hydra.\nMultiple versions cannot be installed simultaneously; if another version of the same package is installed, this implies uninstalling it.",
        "name": "install"
      }
    ]
  },
  {
    "name": "hydra.settings",
    "doc": "Functions for user-defined settings that persist across Hydra launches.",
    "items": [
      {
        "def": "hydra.settings.set(key, val)",
        "doc": "Saves the given value for the string key; value must be a string, number, boolean, nil, or a table of any of these, recursively.",
        "name": "set"
      },
      {
        "def": "hydra.settings.get(key) -> val",
        "doc": "Gets the Lua value for the given string key.",
        "name": "get"
      }
    ]
  },
  {
    "name": "hydra.updates",
    "doc": "Check for and install Hydra updates.",
    "items": [
      {
        "def": "hydra.updates.check(fn(isavailable) = nil, failverbosely = false)",
        "doc": "Checks for an update. Calls the given function with a boolean representing whether a new update is available.\nDefault implementation of fn shows a user-notification when an update is available, with the tag \"showupdate\" (for use with notify.register).",
        "name": "check"
      },
      {
        "def": "hydra.updates.install()",
        "doc": "Currently just opens the page containing the update; in the future, this will actually install the update and restart Hydra.",
        "name": "install"
      },
      {
        "def": "hydra.updates.changelogurl",
        "doc": "String of the URL that contains the changelog, rendered via Markdown",
        "name": "changelogurl"
      },
      {
        "def": "hydra.updates.verifyfile(sig, path) -> bool",
        "doc": "Verifies the DSA signatue against the file at the given absolute path using Hydra's public key.",
        "name": "verifyfile"
      },
      {
        "def": "hydra.updates.getversions(fn(versions))",
        "doc": "Low-level function to get list of available Hydra versions; used by hydra.updates.check; you probably want to use hydra.updates.check instead of using this directly.",
        "name": "getversions"
      },
      {
        "def": "hydra.updates.currentversion() -> number",
        "doc": "Return the current Hydra version as a string.",
        "name": "currentversion"
      }
    ]
  },
  {
    "name": "inspect",
    "doc": "For inspecting tables and stuff.\nSee also:\n - http://github.com/kikito/inspect.lua\n - `hydra.licenses`",
    "items": [
      {
        "def": "inspect.inspect(t) -> string",
        "doc": "Returns a pretty-printed string of the table.\nYou can also use `inspect(t)` instead.",
        "name": "inspect"
      }
    ]
  },
  {
    "name": "json",
    "doc": "Functions for converting between Lua values and JSON strings.",
    "items": [
      {
        "def": "json.encode(val[, prettyprint?]) -> str",
        "doc": "Returns a JSON string representing the given value; if prettyprint is true, the resulting string will be quite beautiful.",
        "name": "encode"
      },
      {
        "def": "json.decode(str) -> val",
        "doc": "Returns a Lua value representing the given JSON string.",
        "name": "decode"
      }
    ]
  },
  {
    "name": "logger",
    "doc": "Functionality to assist with debugging and experimentation.",
    "items": [
      {
        "def": "logger.lines = {}",
        "doc": "List of lines logged so far; caps at logger.maxlines. You may clear it by setting it to {} yourself.",
        "name": "lines"
      },
      {
        "def": "logger.maxlines = 500",
        "doc": "Maximum number of lines to be logged.",
        "name": "maxlines"
      },
      {
        "def": "logger.addhandler(fn(str)) -> index",
        "doc": "Registers a function to handle new log lines.",
        "name": "addhandler"
      },
      {
        "def": "logger.removehandler(index)",
        "doc": "Unregisters a function that handles new log lines.",
        "name": "removehandler"
      },
      {
        "def": "logger.show() -> textgrid",
        "doc": "Opens a textgrid that can browse all logs.",
        "name": "show"
      }
    ]
  },
  {
    "name": "mouse",
    "doc": "Functions for manipulating the mouse cursor.",
    "items": [
      {
        "def": "mouse.get() -> point",
        "doc": "Returns the current location of the mouse on the current screen as a point.",
        "name": "get"
      },
      {
        "def": "mouse.set(point)",
        "doc": "Moves the mouse to the given location on the current screen.",
        "name": "set"
      }
    ]
  },
  {
    "name": "notify",
    "doc": "Apple's built-in notifications system.",
    "items": [
      {
        "def": "notify.register(tag, fn()) -> id",
        "doc": "Registers a function to be called when an Apple notification with the given tag is clicked.",
        "name": "register"
      },
      {
        "def": "notify.unregister(id)",
        "doc": "Unregisters a function to no longer be called when an Apple notification with the given tag is clicked.",
        "name": "unregister"
      },
      {
        "def": "notify.unregisterall()",
        "doc": "Unregisters all functions registered for notification-clicks; called automatically when user config reloads.",
        "name": "unregisterall"
      },
      {
        "def": "notify.show(title, subtitle, text, tag)",
        "doc": "Show an Apple notification. Tag is a unique string that identifies this notification; any functions registered for the given tag will be called if the notification is clicked. None of the strings are optional, though they may each be blank.",
        "name": "show"
      }
    ]
  },
  {
    "name": "notify.applistener",
    "doc": "Listen to notifications sent by other apps, and maybe send some yourself.",
    "items": [
      {
        "def": "notify.applistener.new(fn(notification)) -> applistener",
        "doc": "Registers a listener function for inter-app notifications.",
        "name": "new"
      },
      {
        "def": "notify.applistener:start()",
        "doc": "Starts listening for notifications.",
        "name": "start"
      },
      {
        "def": "notify.applistener:stop()",
        "doc": "Stops listening for notifications.",
        "name": "stop"
      },
      {
        "def": "notify.applistener.stopall()",
        "doc": "Stops app applisteners; automatically called when user config reloads.",
        "name": "stopall"
      }
    ]
  },
  {
    "name": "pasteboard",
    "doc": "Interfacing with the pasteboard (aka clipboard)",
    "items": [
      {
        "def": "pasteboard.stringcontents() -> string",
        "doc": "Returns the contents of the pasteboard as a string, or nil if it can't be done",
        "name": "stringcontents"
      }
    ]
  },
  {
    "name": "pathwatcher",
    "doc": "Watch paths recursively for changes.\n\nThis simple example watches your Hydra directory for changes, and when it sees a change, reloads your configs:\n\n    pathwatcher.new(os.getenv(\"HOME\") .. \"/.hydra/\", hydra.reload):start()",
    "items": [
      {
        "def": "pathwatcher.new(path, fn()) -> pathwatcher",
        "doc": "Returns a new pathwatcher that can be started and stopped.",
        "name": "new"
      },
      {
        "def": "pathwatcher:start()",
        "doc": "Registers pathwatcher's fn as a callback when pathwatcher's path or any descendent changes.",
        "name": "start"
      },
      {
        "def": "pathwatcher:stop()",
        "doc": "Unregisters pathwatcher's fn so it won't be called again until the pathwatcher is restarted.",
        "name": "stop"
      },
      {
        "def": "pathwatcher.stopall()",
        "doc": "Calls pathwatcher:stop() for all started pathwatchers; called automatically when user config reloads.",
        "name": "stopall"
      }
    ]
  },
  {
    "name": "repl",
    "doc": "The REPL (Read-Eval-Print-Loop) is excellent for exploring and experiment with Hydra's API.\n\nIt has all of the familiar readline-like keybindings, including C-b, C-f, M-b, M-f, etc; use C-p and C-n to browse command history.\n\nType `help` in the REPL for info on how to use the documentation system.",
    "items": [
      {
        "def": "repl.open()",
        "doc": "Opens a new REPL.\nIn beta versions of Hydra, the REPL was a textgrid; in Hydra 1.0, this function now opens hydra-cli; see https://github.com/sdegutis/hydra-cli\nWhen hydra-cli is installed, this function opens it in a new terminal window; see repl.path.\nWhen it's not installed, this function opens the github page for hydra-cli which includes installation instructions, as a convenience to the user.\nNOTE: This seems to not work when you're using Bash version 4. In this case, you can use something like this intead:\n    os.execute([[osascript -e 'tell application \"Terminal\" to do script \"/usr/local/bin/hydra\" in do script \"\"']])",
        "name": "open"
      },
      {
        "def": "repl.path -> string",
        "doc": "The path to the hydra-cli binary; defaults to \"/usr/local/bin/hydra\"",
        "name": "path"
      }
    ]
  },
  {
    "name": "screen",
    "doc": "Manipulate screens (i.e. monitors).\n\nYou usually get a screen through a window (see `window.screen`). But you can get screens by themselves through this module, albeit not in any defined/useful order.\n\nHydra's coordinate system assumes a grid that is the union of every screen's rect (see `screen.frame_including_dock_and_menu`).\n\nEvery window's position (i.e. `topleft`) and size are relative to this grid, and they're usually within the grid. A window that's semi-offscreen only intersects the grid.",
    "items": [
      {
        "def": "screen:frame_including_dock_and_menu() -> rect",
        "doc": "Returns the screen's rect in absolute coordinates, including the dock and menu.",
        "name": "frame_including_dock_and_menu"
      },
      {
        "def": "screen:frame_without_dock_or_menu() -> rect",
        "doc": "Returns the screen's rect in absolute coordinates, without the dock or menu.",
        "name": "frame_without_dock_or_menu"
      },
      {
        "def": "screen:next() -> screen",
        "doc": "Returns the screen 'after' this one (I have no idea how they're ordered though); this method wraps around to the first screen.",
        "name": "next"
      },
      {
        "def": "screen:previous() -> screen",
        "doc": "Returns the screen 'before' this one (I have no idea how they're ordered though); this method wraps around to the last screen.",
        "name": "previous"
      },
      {
        "def": "screen:toeast()",
        "doc": "Get the first screen to the east of this one, ordered by proximity.",
        "name": "toeast"
      },
      {
        "def": "screen:towest()",
        "doc": "Get the first screen to the west of this one, ordered by proximity.",
        "name": "towest"
      },
      {
        "def": "screen:tonorth()",
        "doc": "Get the first screen to the north of this one, ordered by proximity.",
        "name": "tonorth"
      },
      {
        "def": "screen:tosouth()",
        "doc": "Get the first screen to the south of this one, ordered by proximity.",
        "name": "tosouth"
      },
      {
        "def": "screen:frame(screen) -> rect",
        "doc": "Returns a screen's frame in its own coordinate space.\n\nNOTE: you probably want to use screen:frame_including_dock_and_menu() instead.",
        "name": "frame"
      },
      {
        "def": "screen:visibleframe(screen) -> rect",
        "doc": "Returns a screen's frame in its own coordinate space, without the dock or menu.\n\nNOTE: you probably want to use screen:frame_without_dock_or_menu() instead.",
        "name": "visibleframe"
      },
      {
        "def": "screen.settint(redarray, greenarray, bluearray)",
        "doc": "Set the tint on a screen; experimental.",
        "name": "settint"
      },
      {
        "def": "screen.allscreens() -> screen[]",
        "doc": "Returns all the screens there are.",
        "name": "allscreens"
      },
      {
        "def": "screen.mainscreen() -> screen",
        "doc": "Returns the 'main' screen, i.e. the one containing the currently focused window.",
        "name": "mainscreen"
      }
    ]
  },
  {
    "name": "spaces",
    "doc": "Experimental API for Spaces support.",
    "items": [
      {
        "def": "spaces.count() -> number",
        "doc": "The number of spaces you currently have.",
        "name": "count"
      },
      {
        "def": "spaces.currentspace() -> number",
        "doc": "The index of the space you're currently on, 1-indexed (as usual).",
        "name": "currentspace"
      },
      {
        "def": "spaces.movetospace(number)",
        "doc": "Switches to the space at the given index, 1-indexed (as usual).\nCAUTION: this behaves very strangely on 10.9, for me at least. It probably works better on 10.8, and may not work at all on 10.10. Use at your own risk!",
        "name": "movetospace"
      }
    ]
  },
  {
    "name": "textgrid",
    "doc": "Super easy in-Hydra GUI windows.",
    "items": [
      {
        "def": "textgrid.create() -> textgrid",
        "doc": "Creates a new (hidden) textgrid window.",
        "name": "create"
      },
      {
        "def": "textgrid:destroy()",
        "doc": "Destroy the given textgrid window; after calling this, it can no longer be used; to temporarily hide it, use textgrid:hide() instead.",
        "name": "destroy"
      },
      {
        "def": "textgrid:protect()",
        "doc": "Prevents the textgrid from being destroyed when your config is reloaded.",
        "name": "protect"
      },
      {
        "def": "textgrid.destroyall()",
        "doc": "Destroys all non-protected textgrids; called automatically when user config is reloaded.",
        "name": "destroyall"
      },
      {
        "def": "textgrid:window() -> window",
        "doc": "Return a window (i.e. of the `window` module) that represents the given textgrid.",
        "name": "window"
      },
      {
        "def": "textgrid:getsize() -> size",
        "doc": "Returns the size (nubmer of rows and columns) as a size-table with keys {x,y}.",
        "name": "getsize"
      },
      {
        "def": "textgrid:setchar(str, x, y)",
        "doc": "Sets the given 1-character UTF-8 encoded string at the given grid coordinates.",
        "name": "setchar"
      },
      {
        "def": "textgrid:setcharfg(str, x, y)",
        "doc": "Sets the textgrid's foreground color to the given 6-digit hex string at the given coordinate.",
        "name": "setcharfg"
      },
      {
        "def": "textgrid:setcharbg(str, x, y)",
        "doc": "Sets the textgrid's background color to the given 6-digit hex string at the given coordinate.",
        "name": "setcharbg"
      },
      {
        "def": "textgrid:clear()",
        "doc": "Replaces all the textgrid's text with space characters.",
        "name": "clear"
      },
      {
        "def": "textgrid:setbg(str)",
        "doc": "Sets the textgrid's background color to the given 6-digit hex string.",
        "name": "setbg"
      },
      {
        "def": "textgrid:setfg(str)",
        "doc": "Sets the textgrid's foreground color to the given 6-digit hex string.",
        "name": "setfg"
      },
      {
        "def": "textgrid:resize(size)",
        "doc": "Resizes the textgrid to the number of rows and columns given in the size-table with keys {w,h}.",
        "name": "resize"
      },
      {
        "def": "textgrid:usefont(name, pointsize)",
        "doc": "Sets the new font of the textgrid, potentially changing its visible size (no resize event is fired).",
        "name": "usefont"
      },
      {
        "def": "textgrid:getfont() -> name, pointsize",
        "doc": "Gets the name and pointsize currently used in the textgrid.",
        "name": "getfont"
      },
      {
        "def": "textgrid:settitle(title)",
        "doc": "Changes the title of the textgrid window.",
        "name": "settitle"
      },
      {
        "def": "textgrid:id() -> number",
        "doc": "Returns a unique identifier for the textgrid's window.",
        "name": "id"
      },
      {
        "def": "textgrid:focus()",
        "doc": "Brings the textgrid to front and focuses it; implicitly focuses Hydra.",
        "name": "focus"
      },
      {
        "def": "textgrid:sethasborder(bool)",
        "doc": "Set whether a textgrid window has a border.",
        "name": "sethasborder"
      },
      {
        "def": "textgrid:sethastitlebar(bool)",
        "doc": "Set whether a textgrid window has a title bar.",
        "name": "sethastitlebar"
      },
      {
        "def": "textgrid:sethasshadow(bool)",
        "doc": "Set whether a textgrid window has a shadow.",
        "name": "sethasshadow"
      },
      {
        "def": "textgrid:show()",
        "doc": "Shows the textgrid; does not focus it, use tg:window():focus() for that.",
        "name": "show"
      },
      {
        "def": "textgrid:hide()",
        "doc": "Hides the textgrid; if shown again, will appear in same place.",
        "name": "hide"
      },
      {
        "def": "textgrid:center()",
        "doc": "Centers the textgrid on the screen it's on.",
        "name": "center"
      },
      {
        "def": "textgrid:resized(fn())",
        "doc": "Calls the given function when the textgrid is resized.",
        "name": "resized"
      },
      {
        "def": "textgrid:keydown(fn(t))",
        "doc": "Calls the given function when a key is pressed in the focused textgrid. The table t contains keys {ctrl, alt, cmd, key}.",
        "name": "keydown"
      },
      {
        "def": "textgrid:hidden(fn())",
        "doc": "Calls the given function when the textgrid is hidden, whether by the user or through the API.",
        "name": "hidden"
      }
    ]
  },
  {
    "name": "timer",
    "doc": "Execute functions with various timing rules.",
    "items": [
      {
        "def": "timer.seconds(n) -> sec",
        "doc": "Returns the number of seconds in seconds.",
        "name": "seconds"
      },
      {
        "def": "timer.minutes(n) -> sec",
        "doc": "Returns the number of minutes in seconds.",
        "name": "minutes"
      },
      {
        "def": "timer.hours(n) -> sec",
        "doc": "Returns the number of hours in seconds.",
        "name": "hours"
      },
      {
        "def": "timer.days(n) -> sec",
        "doc": "Returns the number of days in seconds.",
        "name": "days"
      },
      {
        "def": "timer.weeks(n) -> sec",
        "doc": "Returns the number of weeks in seconds.",
        "name": "weeks"
      },
      {
        "def": "timer.doafter(sec, fn())",
        "doc": "Runs the function after sec seconds.",
        "name": "doafter"
      },
      {
        "def": "timer.new(interval, fn) -> timer",
        "doc": "Creates a new timer that can be started; interval is specified in seconds as a decimal number.",
        "name": "new"
      },
      {
        "def": "timer:start() -> self",
        "doc": "Begins to execute timer.fn every timer.seconds; calling this does not cause an initial firing of the timer immediately.",
        "name": "start"
      },
      {
        "def": "timer:stop() -> self",
        "doc": "Stops the timer's fn from getting called until started again.",
        "name": "stop"
      },
      {
        "def": "timer.stopall()",
        "doc": "Stops all running timers; called automatically when user config reloads.",
        "name": "stopall"
      }
    ]
  },
  {
    "name": "utf8",
    "doc": "Utilities for handling UTF-8 strings 'correctly'.",
    "items": [
      {
        "def": "utf8.count(str) -> int",
        "doc": "Returns the number of characters as humans would count them.",
        "name": "count"
      },
      {
        "def": "utf8.chars(str) -> {str, ...}",
        "doc": "Splits the string into groups of (UTF-8 encoded) strings representing what humans would consider individual characters.\n\nThe result is a sequential table, such that table.concat(result) produces the original string.",
        "name": "chars"
      }
    ]
  },
  {
    "name": "window",
    "doc": "Functions for managing any window.\n\nTo get windows, see `window.focusedwindow` and `window.visiblewindows`.\n\nTo get window geometrical attributes, see `window.{frame,size,topleft}`.\n\nTo move and resize windows, see `window.set{frame,size,topleft}`.\n\nIt may be handy to get a window's app or screen via `window.application` and `window.screen`.\n\nSee the `screen` module for detailed explanation of how Hydra uses window/screen coordinates.",
    "items": [
      {
        "def": "window.allwindows() -> win[]",
        "doc": "Returns all windows",
        "name": "allwindows"
      },
      {
        "def": "window.windowforid() -> win or nil",
        "doc": "Returns the window for the given id, or nil if it's an invalid id.",
        "name": "windowforid"
      },
      {
        "def": "window:isvisible() -> bool",
        "doc": "True if the app is not hidden and the window is not minimized.\nNOTE: some apps (e.g. in Adobe Creative Cloud) have literally-invisible windows and also like to put them very far offscreen; this method may return true for such windows.",
        "name": "isvisible"
      },
      {
        "def": "window:frame() -> rect",
        "doc": "Get the frame of the window in absolute coordinates.",
        "name": "frame"
      },
      {
        "def": "window:setframe(rect)",
        "doc": "Set the frame of the window in absolute coordinates.",
        "name": "setframe"
      },
      {
        "def": "window:otherwindows_samescreen() -> win[]",
        "doc": "Get other windows on the same screen as self.",
        "name": "otherwindows_samescreen"
      },
      {
        "def": "window:otherwindows_allscreens() -> win[]",
        "doc": "Get every window except this one.",
        "name": "otherwindows_allscreens"
      },
      {
        "def": "window:focus() -> bool",
        "doc": "Try to make this window focused.",
        "name": "focus"
      },
      {
        "def": "window.visiblewindows() -> win[]",
        "doc": "Get all windows on all screens that match window.isvisible.",
        "name": "visiblewindows"
      },
      {
        "def": "window.orderedwindows() -> win[]",
        "doc": "Returns all visible windows, ordered from front to back.",
        "name": "orderedwindows"
      },
      {
        "def": "window:maximize()",
        "doc": "Make this window fill the whole screen its on, without covering the dock or menu.",
        "name": "maximize"
      },
      {
        "def": "window:screen()",
        "doc": "Get the screen which most contains this window (by area).",
        "name": "screen"
      },
      {
        "def": "window:windows_to_east()",
        "doc": "Get all windows east of this one, ordered by closeness.",
        "name": "windows_to_east"
      },
      {
        "def": "window:windows_to_west()",
        "doc": "Get all windows west of this one, ordered by closeness.",
        "name": "windows_to_west"
      },
      {
        "def": "window:windows_to_north()",
        "doc": "Get all windows north of this one, ordered by closeness.",
        "name": "windows_to_north"
      },
      {
        "def": "window:windows_to_south()",
        "doc": "Get all windows south of this one, ordered by closeness.",
        "name": "windows_to_south"
      },
      {
        "def": "window:focuswindow_east()",
        "doc": "Focus the first focus-able window to the east of this one.",
        "name": "focuswindow_east"
      },
      {
        "def": "window:focuswindow_west()",
        "doc": "Focus the first focus-able window to the west of this one.",
        "name": "focuswindow_west"
      },
      {
        "def": "window:focuswindow_north()",
        "doc": "Focus the first focus-able window to the north of this one.",
        "name": "focuswindow_north"
      },
      {
        "def": "window:focuswindow_south()",
        "doc": "Focus the first focus-able window to the south of this one.",
        "name": "focuswindow_south"
      },
      {
        "def": "window.focusedwindow() -> window",
        "doc": "Returns the focused window, or nil.",
        "name": "focusedwindow"
      },
      {
        "def": "window:title() -> string",
        "doc": "Returns the title of the window (as UTF8).",
        "name": "title"
      },
      {
        "def": "window:subrole() -> string",
        "doc": "Returns the subrole of the window, whatever that means.",
        "name": "subrole"
      },
      {
        "def": "window:role() -> string",
        "doc": "Returns the role of the window, whatever that means.",
        "name": "role"
      },
      {
        "def": "window:isstandard() -> bool",
        "doc": "True if the window's subrole indicates it's 'a standard window'.",
        "name": "isstandard"
      },
      {
        "def": "window:topleft() -> point",
        "doc": "The top-left corner of the window in absolute coordinates.",
        "name": "topleft"
      },
      {
        "def": "window:size() -> size",
        "doc": "The size of the window.",
        "name": "size"
      },
      {
        "def": "window:settopleft(point)",
        "doc": "Moves the window to the given point in absolute coordinate.",
        "name": "settopleft"
      },
      {
        "def": "window:setsize(size)",
        "doc": "Resizes the window.",
        "name": "setsize"
      },
      {
        "def": "window:close() -> bool",
        "doc": "Closes the window; returns whether it succeeded.",
        "name": "close"
      },
      {
        "def": "window:setfullscreen(bool) -> bool",
        "doc": "Sets whether the window is full screen; returns whether it succeeded.",
        "name": "setfullscreen"
      },
      {
        "def": "window:isfullscreen() -> bool or nil",
        "doc": "Returns whether the window is full screen, or nil if asking that question fails.",
        "name": "isfullscreen"
      },
      {
        "def": "window:minimize()",
        "doc": "Minimizes the window.",
        "name": "minimize"
      },
      {
        "def": "window:unminimize()",
        "doc": "Un-minimizes the window.",
        "name": "unminimize"
      },
      {
        "def": "window:isminimized() -> bool",
        "doc": "True if the window is currently minimized in the dock.",
        "name": "isminimized"
      },
      {
        "def": "window:application() -> app",
        "doc": "Returns the app that the window belongs to.",
        "name": "application"
      },
      {
        "def": "window:becomemain() -> bool",
        "doc": "Make this window the main window of the given application; deos not implicitly focus the app.",
        "name": "becomemain"
      },
      {
        "def": "window:id() -> number, sometimes nil",
        "doc": "Returns a unique number identifying this window.",
        "name": "id"
      }
    ]
  }
]